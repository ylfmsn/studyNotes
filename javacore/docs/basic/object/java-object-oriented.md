---
title: Java 面向对象
date: 2017/11/14
categories:
- javacore
tags:
- javacore
- basics
---

# Java 面向对象

几乎所有 Java 教程对于 Java 的第一个定义都是：Java 是一门面向对象语言。在 Java 中，一切皆为对象。这样的话，听上去很绕，但其实并不是什么很高深的概念。

了解面向对象之前，我们先细思一下编程以及编程语言的本质。

## 抽象、封装、对象、属性、行为、类

### 封装思想

程序员希望计算机能够模拟现实世界的场景，代替人去执行计算任务。计算机不能理解现实场景的事物，需要程序员模拟现实场景，转化为机器能够识别的语言，这个过程就叫做**抽象**。

**那么如何抽象事物呢，或者说描述事物呢？**

一般我们都会从属性或行为两个维度去描述某个事物。举几个例子吧：

如果描述一个动物，我们定义它的属性或者状态，会列举它的各种特征：体重、高度、颜色、类别等等。而描述它的行为时，会列举它是会飞、会跑或是会游泳等等。

如果描述一个东西，比方说一盏台灯，那么描述它的特征，一般会提到颜色、重量、大小、形状、亮度等等。而描述它的行为时，则会提到开灯、关灯、调节亮度这些行为。

。。。

在特定的描述场景中，具有共性的事物常常被归为一个类别。Java 中提供了类（`class`）来描述具有共性的事物，通过提供属性和方法来描述事物的属性和行为，并将其组合为一个有机整体。而类的每个实例被称为**对象**。由现实事物抽象为类的过程叫做**封装**。

> 类：是抽象的概念集合，表示的具有共性的一类事物，类之中定义了属性（编程语言中一般叫做属性、字段、成员）和行为（编程语言中一般叫做方法、函数）。类的实例被称为**对象**。

理解了以上概念，应该就不难理解**一切皆为对象**这句话了。在面向对象语言中，所有事物都可以用类来抽象其属性、行为。事物的个体（对象、实例）。

**例**

```java
public class Person {
    private String name; // 属性，用来描述事物的属性、状态
    private int age; // 属性，用来描述事物的属性、状态
    private String sex; // 属性，用来描述事物的属性、状态
    public void look(){} // 方法，用来描述事物的行为
    public void hear(){} // 方法，用来描述事物的行为
    public void talk(){} // 方法，用来描述事物的行为

    public static void main(String[] args) {
        Person zhangsan = new Person(); // 对象
        Person lisi = new Person(); // 对象
    }
}
```

## 继承、抽象类

### 继承思想

现实世界中，不同类的事物可以因为存在许多共性，而被归纳为一个大类。如树木、花草等都属于植物；鸟、鱼、猫、狗等都属于动物。

在编程中，抽象这些类的事物时，会出现很多重复的属性或行为。如：

鸟：属性-重量、大小；行为-移动、吃鱼：属性-重量、大小；行为-移动、吃

为了消除这些冗余代码，Java 中允许类之间存在继承机制。

### 继承机制

（1）子类继承父类所有非 `private` 的属性和方法，子类可以拥有自己的属性和方法。

> 注意：在 Java 中，父类一定是子类，但是子类不一定是父类。

**例**

```
// class Dog extends Animal {...}
Animal dog = new Dog(); // 正确。父类一定是子类。
Dog dog = new Animal(); // 错误。子类不一定是父类。
```

（2）子类可以覆写父类的方法。

**例**

```
// 覆写父类方法示例
public class Animal {
    protected void eat() {
        System.out.println("吃东西");
    }
}
public class Dog extends Animal {
    @Override
    protected void eat() {
        System.out.println("吃骨头");
    }

    public static void main(String[] args) {
	    Animal dog = new Dog();
        dog.eat();
    }
}
// output: 吃骨头
```

（3）Java 不支持多继承，但是支持多重继承

**例**

A 是 B 的父类，B 是 C 的父类，所以 A 也是 C 的父类。

```
// 多重继承示例
public class A {}
public class B extends A {}
public class C extends B {}
```

## 多态

多态是同一个行为具有多个不同表现形式或形态的能力。

### 多态的优点

* \1. 消除类型之间的耦合关系
* \2. 可替换性
* \3. 可扩充性
* \4. 接口性
* \5. 灵活性
* \6. 简化性

### 多态存在的三个必要条件

* 继承
* 重写
* 父类引用指向子类对象

```
Parent p = new Child();
```

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。

多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。

### 虚方法

我们将介绍在 Java 中，当设计类时，被重写的方法的行为怎样影响多态性。

我们已经讨论了方法的重写，也就是子类能够重写父类的方法。

当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。

要想调用父类中被重写的方法，则必须使用关键字 super。

### 多态的实现方式

方式一：重写：

这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：

Java 重写(Override)与重载(Overload)

方式二：接口

* \1. 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。
* \2. java 中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 [java 接口](http://www.runoob.com/java/java-interfaces.html) 这一章节的内容。

方式三：抽象类和抽象方法

## 抽象类

在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。

抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。

由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。

父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。

在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。

### 抽象类总结规定

* \1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
* \2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
* \3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
* \4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
* \5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

## 接口

接口（英文：Interface），在 JAVA 编程语言中是一个抽象类型，是抽象方法的集合，接口通常以 interface 来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。

接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。

### 接口与类相似点：

* 一个接口可以有多个方法。
* 接口文件保存在 .java 结尾的文件中，文件名使用接口名。
* 接口的字节码文件保存在 .class 结尾的文件中。
* 接口相应的字节码文件必须在与包名称相匹配的目录结构中。

### 接口与类的区别：

* 接口不能用于实例化对象。
* 接口没有构造方法。
* 接口中所有的方法必须是抽象方法。
* 接口不能包含成员变量，除了 static 和 final 变量。
* 接口不是被类继承了，而是要被类实现。
* 接口支持多继承。

### 接口特性

* 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 **public abstract**（只能是 public abstract，其他修饰符都会报错）。
* 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误）。
* 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。

### 抽象类和接口的区别

* \1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
* \2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。
* \3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
* \4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

接口声明

接口实现

接口多继承
