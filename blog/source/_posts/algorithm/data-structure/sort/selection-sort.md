---
title: 简单选择排序
date: 2015-03-07
categories:
- algorithm
tags:
- algorithm
- sort
---

# 简单选择排序

## 要点

> 简单选择排序是一种**选择排序**。
>
> **选择排序**：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。
>

## 算法思想

1. 从待排序序列中，找到关键字最小的元素；

2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；

3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复 1、2 步，直到排序结束。

如图所示，每趟排序中，将当前**第 i 小的元素放在位置 i **上。

**核心代码**

<br><div align="center"><img src="http://oyz7npk35.bkt.clouddn.com//image/algorithm/sort/selection-sort.png"/></div><br>

## 算法分析

**简单选择排序算法的性能**

| 参数        | 结果     |
| --------- | ------ |
| 排序类别      | 选择排序   |
| 排序方法      | 简单选择排序 |
| 时间复杂度平均情况 | O(N2)  |
| 时间复杂度最坏情况 | O(N2)  |
| 时间复杂度最好情况 | O(N2)  |
| 空间复杂度     | O(1)   |
| 稳定性       | 不稳定    |
| 复杂性       | 简单     |

### 时间复杂度

简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 **N** 个元素，则**比较次数总是 N (N - 1) / 2 **。

而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 **0**.

当序列反序时，移动次数最多，为 **3N (N - 1) /  2**。

所以，综合以上，简单排序的时间复杂度为 **O(N2)**。 

### 空间复杂度

简单选择排序需要占用一个临时空间，在交换数值时使用。

## 示例代码

[我的 Github 测试例](https://github.com/dunwu/algorithm-notes/blob/master/codes/src/test/java/io/github/dunwu/algorithm/sort/SortStrategyTest.java)

样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。
